#!/usr/bin/env python3
"""
í•µì‹¬ OCR ì—”ì§„ ëª¨ë“ˆ - Pororo OCR ìµœì í™” ì™„ì „ ìˆ˜ì • ë²„ì „
"""

import os
import logging
import traceback
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime

logger = logging.getLogger(__name__)

class OCREngine:
    """Pororo OCR ì—”ì§„ ëž˜í¼ í´ëž˜ìŠ¤ - ì™„ì „ ìˆ˜ì • ë²„ì „"""

    def __init__(self, model: str = "brainocr", language: str = "ko"):
        self.model = model
        self.language = language
        self.ocr = None
        self._initialize_ocr()

    def _initialize_ocr(self):
        """OCR ëª¨ë¸ ì´ˆê¸°í™”"""
        try:
            from pororo import Pororo
            logger.info(f"ðŸš€ Pororo OCR ì´ˆê¸°í™”: {self.model} ({self.language})")
            
            self.ocr = Pororo(
                task="ocr",
                lang=self.language,
                model=self.model
            )
            logger.info(f"âœ… OCR ì—”ì§„ ì´ˆê¸°í™” ì„±ê³µ")
            
        except ImportError:
            logger.error("âŒ Pororo ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            raise ImportError("Pororo library is not installed. Please install it with: pip install pororo")
        except Exception as e:
            logger.error(f"âŒ OCR ì—”ì§„ ì´ˆê¸°í™” ì‹¤íŒ¨: {str(e)}")
            logger.error(traceback.format_exc())
            raise

    def extract_text(self, image_path: str, detail: bool = True) -> List[Dict[str, Any]]:
        """ì´ë¯¸ì§€ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ - Pororo ìµœì í™” ë²„ì „"""
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"Image file not found: {image_path}")

        try:
            logger.info(f"ðŸ” OCR ì²˜ë¦¬: {os.path.basename(image_path)}")
            
            # Pororo OCR ì‹¤í–‰ - detail=Trueë¡œ ëª¨ë“  ì •ë³´ íšë“
            result = self.ocr(image_path, detail=True)
            
            logger.debug(f"ðŸ“‹ OCR ì›ë³¸ ê²°ê³¼ íƒ€ìž…: {type(result)}")
            logger.debug(f"ðŸ“‹ OCR ì›ë³¸ ê²°ê³¼: {result}")

            # Pororo ì „ìš© ê²°ê³¼ ì •ê·œí™”
            normalized_results = self._normalize_pororo_results(result, image_path)

            logger.info(f"âœ… í…ìŠ¤íŠ¸ ì¶”ì¶œ ì™„ë£Œ: {len(normalized_results)}ê°œ ì˜ì—­")
            
            for i, region in enumerate(normalized_results[:3]):
                sample_text = region.get('text', '')[:100]
                logger.info(f"   ì˜ì—­ {i+1}: '{sample_text}'")

            return normalized_results

        except Exception as e:
            logger.error(f"âŒ OCR ì¶”ì¶œ ì‹¤íŒ¨: {image_path} - {str(e)}")
            logger.error(traceback.format_exc())
            return []

    def _normalize_pororo_results(self, raw_results: Any, image_path: str) -> List[Dict[str, Any]]:
        """Pororo OCR ê²°ê³¼ ì •ê·œí™” - ì‹¤ì œ êµ¬ì¡° ê¸°ë°˜"""
        normalized = []
        
        logger.debug(f"ðŸ”§ ì •ê·œí™” ì‹œìž‘ - íƒ€ìž…: {type(raw_results)}")
        
        if not raw_results:
            logger.warning("âš ï¸ OCR ê²°ê³¼ê°€ ë¹„ì–´ìžˆìŠµë‹ˆë‹¤")
            return normalized

        try:
            # Pororo OCR ê²°ê³¼ êµ¬ì¡°ë³„ ì²˜ë¦¬
            if isinstance(raw_results, dict):
                # detail=True ê²°ê³¼: {'description': [...], 'bounding_poly': [...]}
                if 'description' in raw_results and 'bounding_poly' in raw_results:
                    descriptions = raw_results['description']
                    bounding_polys = raw_results['bounding_poly']
                    
                    logger.debug(f"   descriptions: {len(descriptions)}ê°œ, bounding_polys: {len(bounding_polys)}ê°œ")
                    
                    for i, (desc, poly) in enumerate(zip(descriptions, bounding_polys)):
                        if desc and desc.strip():
                            # ë°”ìš´ë”© ë°•ìŠ¤ ì¶”ì¶œ
                            bbox = [0, 0, 0, 0]
                            vertices = poly.get('vertices', [])
                            if vertices and len(vertices) >= 2:
                                x_coords = [v.get('x', 0) for v in vertices]
                                y_coords = [v.get('y', 0) for v in vertices]
                                bbox = [min(x_coords), min(y_coords), max(x_coords), max(y_coords)]
                            
                            text_content = {
                                'id': i,
                                'text': desc.strip(),
                                'confidence': 0.95,  # PororoëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì‹ ë¢°ë„ê°€ ë†’ìŒ
                                'bbox': bbox,
                                'source_image': image_path,
                                'extracted_at': datetime.now().isoformat()
                            }
                            normalized.append(text_content)
                            logger.debug(f"   ì¶”ê°€: '{desc.strip()[:50]}'")
                
                else:
                    # ë‹¤ë¥¸ ë”•ì…”ë„ˆë¦¬ êµ¬ì¡°
                    text_content = self._extract_text_from_dict(raw_results, image_path, 0)
                    if text_content:
                        normalized.append(text_content)
                        
            elif isinstance(raw_results, list):
                logger.debug(f"ðŸ“Š ë¦¬ìŠ¤íŠ¸ ê²°ê³¼ - ê¸¸ì´: {len(raw_results)}")
                
                for i, item in enumerate(raw_results):
                    if isinstance(item, tuple) and len(item) >= 2:
                        # (bbox, text, confidence) êµ¬ì¡°
                        text = item[1] if len(item) > 1 else ""
                        confidence = item[2] if len(item) > 2 else 0.95
                        bbox_info = item[0] if len(item) > 0 else []
                        
                        if text and text.strip():
                            # ë°”ìš´ë”© ë°•ìŠ¤ ì²˜ë¦¬
                            bbox = [0, 0, 0, 0]
                            if bbox_info:
                                try:
                                    if isinstance(bbox_info[0], (list, tuple)):
                                        # [[x1,y1], [x2,y2], ...] í˜•íƒœ
                                        x_coords = [pt[0] for pt in bbox_info if len(pt) >= 2]
                                        y_coords = [pt[1] for pt in bbox_info if len(pt) >= 2]
                                        if x_coords and y_coords:
                                            bbox = [min(x_coords), min(y_coords), max(x_coords), max(y_coords)]
                                    else:
                                        # [x1, y1, x2, y2] í˜•íƒœ
                                        bbox = list(bbox_info[:4])
                                except:
                                    pass
                            
                            text_content = {
                                'id': i,
                                'text': text.strip(),
                                'confidence': float(confidence) if confidence else 0.95,
                                'bbox': bbox,
                                'source_image': image_path,
                                'extracted_at': datetime.now().isoformat()
                            }
                            normalized.append(text_content)
                            logger.debug(f"   ì¶”ê°€: '{text.strip()[:50]}'")
                    
                    elif isinstance(item, dict):
                        text_content = self._extract_text_from_dict(item, image_path, i)
                        if text_content:
                            normalized.append(text_content)
                    
                    elif isinstance(item, str) and item.strip():
                        text_content = {
                            'id': i,
                            'text': item.strip(),
                            'confidence': 0.95,
                            'bbox': [0, 0, 0, 0],
                            'source_image': image_path,
                            'extracted_at': datetime.now().isoformat()
                        }
                        normalized.append(text_content)
                        logger.debug(f"   ì¶”ê°€: '{item.strip()[:50]}'")
            
            elif isinstance(raw_results, str) and raw_results.strip():
                text_content = {
                    'id': 0,
                    'text': raw_results.strip(),
                    'confidence': 0.95,
                    'bbox': [0, 0, 0, 0],
                    'source_image': image_path,
                    'extracted_at': datetime.now().isoformat()
                }
                normalized.append(text_content)
                logger.debug(f"   ë¬¸ìžì—´ ì¶”ê°€: '{raw_results.strip()[:50]}'")
            
            else:
                logger.warning(f"âš ï¸ ì•Œ ìˆ˜ ì—†ëŠ” ê²°ê³¼ í˜•íƒœ: {type(raw_results)}")
                # ë§ˆì§€ë§‰ ì‹œë„
                try:
                    str_result = str(raw_results).strip()
                    if str_result and str_result not in ['None', 'null', '[]', '{}']:
                        text_content = {
                            'id': 0,
                            'text': str_result,
                            'confidence': 0.5,
                            'bbox': [0, 0, 0, 0],
                            'source_image': image_path,
                            'extracted_at': datetime.now().isoformat()
                        }
                        normalized.append(text_content)
                        logger.debug(f"   ë³€í™˜ ì¶”ê°€: '{str_result[:50]}'")
                except:
                    logger.error(f"âŒ ê²°ê³¼ ë³€í™˜ ì‹¤íŒ¨: {type(raw_results)}")
        
        except Exception as e:
            logger.error(f"âŒ ì •ê·œí™” ì¤‘ ì˜¤ë¥˜: {str(e)}")
            logger.error(traceback.format_exc())
        
        logger.info(f"ðŸŽ¯ ì •ê·œí™” ì™„ë£Œ: {len(normalized)}ê°œ í…ìŠ¤íŠ¸ ì˜ì—­")
        return normalized

    def _extract_text_from_dict(self, item: dict, image_path: str, index: int) -> Optional[Dict[str, Any]]:
        """ë”•ì…”ë„ˆë¦¬ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ"""
        try:
            text = ""
            confidence = 0.95
            bbox = [0, 0, 0, 0]
            
            # í…ìŠ¤íŠ¸ ì¶”ì¶œ
            text_keys = ['description', 'text', 'word', 'content', 'ocr_text']
            for key in text_keys:
                if key in item and item[key]:
                    text = str(item[key]).strip()
                    break
            
            # ì‹ ë¢°ë„ ì¶”ì¶œ
            conf_keys = ['confidence', 'score', 'prob']
            for key in conf_keys:
                if key in item:
                    try:
                        confidence = float(item[key])
                        break
                    except:
                        continue
            
            # ë°”ìš´ë”© ë°•ìŠ¤ ì¶”ì¶œ
            if 'vertices' in item:
                vertices = item['vertices']
                if vertices:
                    try:
                        x_coords = [v.get('x', 0) for v in vertices if 'x' in v]
                        y_coords = [v.get('y', 0) for v in vertices if 'y' in v]
                        if x_coords and y_coords:
                            bbox = [min(x_coords), min(y_coords), max(x_coords), max(y_coords)]
                    except:
                        pass
            
            if text:
                return {
                    'id': index,
                    'text': text,
                    'confidence': confidence,
                    'bbox': bbox,
                    'source_image': image_path,
                    'extracted_at': datetime.now().isoformat()
                }
                
        except Exception as e:
            logger.debug(f"ë”•ì…”ë„ˆë¦¬ ì¶”ì¶œ ì‹¤íŒ¨ {index}: {str(e)}")
        
        return None

    def batch_extract(self, image_paths: List[str], progress_callback: Optional[callable] = None) -> Dict[str, List[Dict[str, Any]]]:
        """ë°°ì¹˜ í…ìŠ¤íŠ¸ ì¶”ì¶œ"""
        results = {}
        total = len(image_paths)

        logger.info(f"ðŸš€ ë°°ì¹˜ OCR ì‹œìž‘: {total}ê°œ ì´ë¯¸ì§€")

        for i, image_path in enumerate(image_paths):
            try:
                logger.info(f"ðŸ“ ì²˜ë¦¬: {i+1}/{total} - {os.path.basename(image_path)}")
                results[image_path] = self.extract_text(image_path)

                if progress_callback:
                    progress_callback(i + 1, total, image_path)

            except Exception as e:
                logger.error(f"âŒ ë°°ì¹˜ ì²˜ë¦¬ ì‹¤íŒ¨ {image_path}: {str(e)}")
                results[image_path] = []

        successful = len([r for r in results.values() if r])
        logger.info(f"âœ… ë°°ì¹˜ OCR ì™„ë£Œ: {successful}/{total} ì„±ê³µ")
        
        return results

    def get_supported_formats(self) -> List[str]:
        return ['.png', '.jpg', '.jpeg', '.bmp', '.tiff', '.tif']

    def validate_image(self, image_path: str) -> bool:
        if not os.path.exists(image_path):
            return False
        ext = os.path.splitext(image_path)[1].lower()
        return ext in self.get_supported_formats()

    def get_engine_info(self) -> Dict[str, Any]:
        return {
            'model': self.model,
            'language': self.language,
            'supported_formats': self.get_supported_formats(),
            'initialized': self.ocr is not None,
            'engine_type': 'Pororo OCR (Enhanced)',
            'version': 'Enhanced 1.0'
        }


class OCRResult:
    """OCR ê²°ê³¼ ë°ì´í„° í´ëž˜ìŠ¤"""

    def __init__(self, text_regions: List[Dict[str, Any]], source_image: str):
        self.text_regions = text_regions
        self.source_image = source_image
        self.extracted_at = datetime.now()

    @property
    def text_count(self) -> int:
        return len(self.text_regions)

    @property
    def combined_text(self) -> str:
        return '\n'.join(region['text'] for region in self.text_regions if region['text'].strip())

    @property
    def confidence_scores(self) -> List[float]:
        return [region['confidence'] for region in self.text_regions]

    @property
    def average_confidence(self) -> float:
        scores = self.confidence_scores
        return sum(scores) / len(scores) if scores else 0.0

    def get_high_confidence_text(self, threshold: float = 0.8) -> List[str]:
        return [
            region['text']
            for region in self.text_regions
            if region['confidence'] >= threshold and region['text'].strip()
        ]

    def to_dict(self) -> Dict[str, Any]:
        return {
            'source_image': self.source_image,
            'extracted_at': self.extracted_at.isoformat(),
            'text_count': self.text_count,
            'combined_text': self.combined_text,
            'average_confidence': self.average_confidence,
            'text_regions': self.text_regions
        }
